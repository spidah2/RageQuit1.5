// spells.js - autogenerated module from original game.js

function startCasting(spellId, type, key) {
            if (castingState.active) return;
            let castTime = 0.5; if (spellId === 1) castTime = 0.2; if (spellId === 4) castTime = 0.0;
            
            if (type === 'bow_shot') {
                castTime = GAME_CONFIG.SPELL_CAST_TIMES[5];
            } else if (type === 'attack' && spellId !== 4) {
                let cost = (spellId===1)?GAME_CONFIG.SPELL_COSTS[1]:(spellId===2)?GAME_CONFIG.SPELL_COSTS[2]:(spellId===3)?GAME_CONFIG.SPELL_COSTS[3]:GAME_CONFIG.SPELL_COSTS[4];
                if (playerStats.mana < cost) { addToLog("Insufficient Mana!", "#555"); return; }
            } else if (type === 'conversion') {
                const now = performance.now();
                if (now - lastConversionTime < GAME_CONFIG.SPELL_PARAMS.CONVERSION_COOLDOWN) { addToLog("Recharging...", "#aaa"); return; }
            }
            if (castTime === 0) {
                if (type === 'attack') executeAttack(spellId); else if (type === 'conversion') executeConversion(spellId); return;
            }
            castingState.active = true; castingState.timer = 0; castingState.maxTime = castTime; castingState.currentSpell = spellId; castingState.type = type; castingState.ready = false; castingState.keyHeld = key;
            document.getElementById('cast-bar-container').style.display = 'block'; document.getElementById('cast-text').innerText = "CHARGING..."; document.getElementById('cast-bar-fill').className = ''; 
        }

function stopCasting(key) {
            if (!castingState.active) return;
            if (castingState.keyHeld === key) {
                if (castingState.ready) { 
                    if (castingState.type === 'attack') executeAttack(castingState.currentSpell); 
                    else if (castingState.type === 'conversion') executeConversion(castingState.currentSpell);
                    else if (castingState.type === 'bow_shot') executeAttack('bow');
                } else { addToLog("Cast cancelled", "#555"); }
                castingState.active = false; document.getElementById('cast-bar-container').style.display = 'none';
            }
        }

function updateCasting(delta) {
            if (!castingState.active) return;
            castingState.timer += delta; let progress = Math.min(1, castingState.timer / castingState.maxTime);
            document.getElementById('cast-bar-fill').style.width = (progress * 100) + '%';
            if (progress >= 1 && !castingState.ready) { castingState.ready = true; document.getElementById('cast-text').innerText = "READY!"; document.getElementById('cast-bar-fill').className = 'ready'; }
        }

function selectSpell(id) { if(weaponMode !== 'ranged') { weaponMode = 'ranged'; toggleWeapon(true); } currentSpell = id; updateStaffColor(id); updateActionBarUI(); }

function performAttack() {
            if (playerStats.isDead) return;
            if (weaponMode === 'ranged') { startCasting(currentSpell, 'attack', 'Mouse'); } 
            else if (weaponMode === 'bow') { startCasting(null, 'bow_shot', 'Mouse'); }
            else { 
                if(isBlocking) return; 
                if (performance.now() - lastAttackTime < GAME_CONFIG.SPELL_PARAMS.MELEE_RATE) return; 
                lastAttackTime = performance.now(); 
                swingSword(); 
            }
        }

function executeAttack(id) {
            const now = performance.now();
            
            if (id === 'bow') {
                // Arrow shot - Calculate from camera NOW
                let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                const spawnPos = camera.position.clone().add(camDir.multiplyScalar(2));
                spawnProjectile(5); // 5 is Arrow ID
                if (socket) socket.emit('playerAttack', { type: 5, origin: spawnPos, direction: camDir });
                playSound('shoot_bolt'); // Reuse bolt sound
                return;
            }
            
            let cost = (id===1)?GAME_CONFIG.SPELL_COSTS[1]:(id===2)?GAME_CONFIG.SPELL_COSTS[2]:(id===3)?GAME_CONFIG.SPELL_COSTS[3]:GAME_CONFIG.SPELL_COSTS[4];
            if (playerStats.mana < cost) { addToLog("Insufficient Mana!", "#555"); return; }
            if (id === 4 && (now - lastSpikesTime < GAME_CONFIG.SPELL_PARAMS.IMPALE_COOLDOWN)) { addToLog("Impale recharging...", "#aaa"); return; }
            playerStats.mana -= cost; lastAttackTime = now; isAttacking = true; attackTimer = 0;
            
            let camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); let spawnPos = getStaffTip();
            if (id === 4) { lastSpikesTime = now; fireHitscan(); } else { spawnProjectile(id); if (socket) socket.emit('playerAttack', { type: id, origin: spawnPos, direction: camDir }); }
            if(id === 1) playSound('shoot_bolt'); if(id === 3) playSound('shoot_fire'); if(id === 2) playSound('shoot_bolt');
        }

        function performConversion(type) {
            if (playerStats.isDead) return;
            const now = performance.now();
            if (now - lastConversionTime < GAME_CONFIG.SPELL_PARAMS.CONVERSION_COOLDOWN) { addToLog("Recharging...", "#aaa"); return; }            playSound('heal'); 
            // nextTick = 0.5 per evitare lo spike iniziale (prima applicazione dopo 0.5s, poi ogni 1s)
            activeConversions.push({ type: type, duration: 5.0, nextTick: 0.5 }); 
            lastConversionTime = now; 
            updateUI();
            const slotId = (type === 1) ? 'slot-5' : (type === 2) ? 'slot-6' : 'slot-7'; 
            document.getElementById(slotId).classList.add('channeling'); 
            setTimeout(() => document.getElementById(slotId).classList.remove('channeling'), 5000);
            
            let color = (type === 1) ? 0xff0000 : (type === 2) ? 0x0000ff : 0xffff00;
            spawnGlowEffect(color);
            if(socket) socket.emit('playerEffect', { type: (type===1?'heal':(type===2?'mana':'stamina')) });
        }

function updateConversions(delta) {
            for (let i = activeConversions.length - 1; i >= 0; i--) {
                const conv = activeConversions[i]; conv.duration -= delta; conv.nextTick -= delta;
                if (conv.nextTick <= 0) { applyConversionTick(conv.type); conv.nextTick = 1.0; }
                if (conv.duration <= 0) activeConversions.splice(i, 1);
            }
        }

function applyConversionTick(type) {
            // Non applicare conversione se morto
            if (playerStats.isDead) return;
            
            // Usa i valori corretti dal config: cost=5, gain=5 per tick
            // Durata totale: 5 secondi (5 ticks di 1 secondo)
            // Totale conversione: 25 risorse scambiate
            if (type === 1) { 
                // Conversione Stamina → HP
                if (playerStats.stamina >= GAME_CONFIG.SPELL_PARAMS.CONVERSION_STAMINA_TO_HP_COST && playerStats.hp < playerStats.maxHp) { 
                    playerStats.stamina -= GAME_CONFIG.SPELL_PARAMS.CONVERSION_STAMINA_TO_HP_COST; 
                    playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + GAME_CONFIG.SPELL_PARAMS.CONVERSION_STAMINA_TO_HP_GAIN); 
                    if(socket) socket.emit('playerHealed', { amount: GAME_CONFIG.SPELL_PARAMS.CONVERSION_STAMINA_TO_HP_GAIN });
                } 
            } 
            else if (type === 2) { 
                // Conversione HP → Mana
                if (playerStats.hp > GAME_CONFIG.SPELL_PARAMS.CONVERSION_HP_TO_MANA_COST && playerStats.mana < playerStats.maxMana) { 
                    playerStats.hp -= GAME_CONFIG.SPELL_PARAMS.CONVERSION_HP_TO_MANA_COST; 
                    playerStats.mana = Math.min(playerStats.maxMana, playerStats.mana + GAME_CONFIG.SPELL_PARAMS.CONVERSION_HP_TO_MANA_GAIN); 
                } 
            } 
            else if (type === 3) { 
                // Conversione Mana → Stamina
                if (playerStats.mana >= GAME_CONFIG.SPELL_PARAMS.CONVERSION_MANA_TO_STAMINA_COST && playerStats.stamina < playerStats.maxStamina) { 
                    playerStats.mana -= GAME_CONFIG.SPELL_PARAMS.CONVERSION_MANA_TO_STAMINA_COST; 
                    playerStats.stamina = Math.min(playerStats.maxStamina, playerStats.stamina + GAME_CONFIG.SPELL_PARAMS.CONVERSION_MANA_TO_STAMINA_GAIN); 
                } 
            }
            updateUI(); 
        }

        function performHeal() {
            if (playerStats.isDead) return; const now = performance.now();
            if (now - lastHealTime < GAME_CONFIG.SPELL_PARAMS.HEAL_COOLDOWN) { addToLog("Heal on cooldown", "#aaa"); return; }
            if (playerStats.mana < GAME_CONFIG.SPELL_COSTS[6]) { addToLog("Insufficient Mana", "#555"); return; }
            if (playerStats.hp >= playerStats.maxHp) return;
            playerStats.mana -= GAME_CONFIG.SPELL_COSTS[6]; 
            playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + GAME_CONFIG.SPELL_PARAMS.HEAL_AMOUNT);
            if(socket) {
                socket.emit('playerHealed', { amount: GAME_CONFIG.SPELL_PARAMS.HEAL_AMOUNT });
                socket.emit('playerEffect', { type: 'heal' });
            }
            lastHealTime = now; addToLog(`Healed for ${GAME_CONFIG.SPELL_PARAMS.HEAL_AMOUNT} HP`, "heal"); createFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0,5,0)), `+${GAME_CONFIG.SPELL_PARAMS.HEAL_AMOUNT}`, '#00ff00');
            spawnGlowEffect(0x00ff00); flashScreen('green'); playSound('heal'); updateUI(); 
        }

        function performWhirlwind() {
            if (playerStats.isDead || isBlocking) return;
            const now = performance.now();
            if (now - lastWhirlwindTime < GAME_CONFIG.SPELL_PARAMS.WHIRLWIND_COOLDOWN) { addToLog("Whirlwind recharging...", "#aaa"); return; }
            if (playerStats.stamina < GAME_CONFIG.SPELL_PARAMS.WHIRLWIND_COST) { addToLog("Insufficient Stamina!", "#555"); return; }
            playerStats.stamina -= GAME_CONFIG.SPELL_PARAMS.WHIRLWIND_COST; lastWhirlwindTime = now; if (!canJump) return; velocity.y += GAME_CONFIG.SPELL_PARAMS.WHIRLWIND_JUMP_FORCE; canJump = false; isWhirlwinding = true; setTimeout(() => { isWhirlwinding = false; }, 500);
            
            spawnParticles(playerMesh.position, 0xffffff, 40, 60, 0.6, false);
            
            addToLog("WHIRLWIND ACTIVATED!", "spell-cast"); 
            playSound('whirlwind');
            
            if (socket) socket.emit('playerAttack', { type: 'whirlwind', origin: playerMesh.position, direction: new THREE.Vector3() });
            Object.values(otherPlayers).forEach((e) => {
                if (e.mesh.position.distanceTo(playerMesh.position) < GAME_CONFIG.SPELL_PARAMS.WHIRLWIND_RADIUS) {
                    let dmg = GAME_CONFIG.SPELL_PARAMS.WHIRLWIND_DMG;
                    // Controlla se il nemico sta bloccando
                    const isBlocking = e.mesh.userData.isBlocking || false;
                    if(isBlocking) {
                        dmg *= (1.0 - GAME_CONFIG.SPELL_PARAMS.BLOCK_MITIGATION); 
                        createFloatingText(e.mesh.position.clone().add(new THREE.Vector3(0,10,0)), "BLOCK", "#aaa");
                    } else {
                        createFloatingText(e.mesh.position.clone().add(new THREE.Vector3(0,10,0)), `-${Math.round(dmg)}`, "#ff3333");
                    }
                    if (socket) socket.emit('playerHit', { 
                        damage: dmg, 
                        targetId: Object.keys(otherPlayers).find(key => otherPlayers[key] === e),
                        hitPosition: e.mesh.position.clone() // Posizione del target al momento dell'hit
                    });
                }
            });

            updateUI();
        }

function spawnStoneSpikes(target, isSticky = false) {
            const group = new THREE.Group(); const material = new THREE.MeshLambertMaterial({ color: 0x888888 }); 
            for(let i=0; i<8; i++) { 
                const height = 8 + random() * 4; const geo = new THREE.ConeGeometry(1.5, height, 6); const mesh = new THREE.Mesh(geo, material);
                const angle = random() * Math.PI * 2; const radius = 4 + random() * 2; 
                mesh.position.set(Math.cos(angle)*radius, height/2 - 2, Math.sin(angle)*radius);
                mesh.rotation.x = (random() - 0.5) * 0.8; mesh.rotation.z = (random() - 0.5) * 0.8; group.add(mesh);
            }
            if (isSticky && target) { target.add(group); group.position.set(0, 0, 0); } else { scene.add(group); group.position.copy(target instanceof THREE.Vector3 ? target : target.position); }
            setTimeout(() => { if (isSticky && target) target.remove(group); else scene.remove(group); group.children.forEach(c => { c.geometry.dispose(); }); material.dispose(); }, 1500);
        }

function fireHitscan() {
            const raycaster = new THREE.Raycaster(); 
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const opponentMeshes = Object.values(otherPlayers).map(p => p.mesh);
            const intersects = raycaster.intersectObjects([...opponentMeshes, ...obstacles], true);
            
            let enemyFound = null;
            let hitPoint = null;
            
            if(intersects.length > 0) {
                hitPoint = intersects[0].point; 
                const obj = intersects[0].object; 
                let currentObj = obj;
                while(currentObj) { 
                    const foundPlayer = Object.values(otherPlayers).find(p => p.mesh === currentObj);
                    if(foundPlayer) { 
                        enemyFound = currentObj; 
                        break; 
                    } 
                    currentObj = currentObj.parent; 
                }
                if(!enemyFound) {
                    // Raycast hit obstacle, spawn spikes there
                    spawnStoneSpikes(hitPoint, false);
                    addToLog("Stone Spikes activated!", "spell-cast"); 
                    playSound('hit');
                    return;
                }
            } else {
                // No direct collision - check if there's an enemy nearby (close range)
                // Handles case where player is TOO CLOSE to enemy and raycast misses
                let closestEnemy = null;
                let closestDist = Infinity;
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                
                Object.values(otherPlayers).forEach(op => {
                    const distToEnemy = camera.position.distanceTo(op.mesh.position);
                    const angleToEnemy = camera.getWorldDirection(new THREE.Vector3()).angleTo(
                        new THREE.Vector3().subVectors(op.mesh.position, camera.position).normalize()
                    );
                    
                    // If enemy in FOV and very close (< 12), consider it hit
                    if (angleToEnemy < Math.PI / 4 && distToEnemy < 12 && distToEnemy < closestDist) {
                        closestEnemy = op.mesh;
                        closestDist = distToEnemy;
                    }
                });
                
                if(closestEnemy) {
                    enemyFound = closestEnemy;
                    hitPoint = closestEnemy.position.clone();
                } else {
                    // No enemy found, just spawn spikes at max distance
                    const spawnDist = 200;
                    hitPoint = camera.position.clone().add(camDir.multiplyScalar(spawnDist));
                    spawnStoneSpikes(hitPoint, false);
                    addToLog("Stone Spikes activated!", "spell-cast"); 
                    playSound('hit');
                    return;
                }
            }
            
            if(enemyFound) {
                spawnStoneSpikes(enemyFound, true); 
                const hitId = Object.keys(otherPlayers).find(key => otherPlayers[key].mesh === enemyFound);
                if(hitId && socket) {
                    let dmg = GAME_CONFIG.SPELL_PARAMS.BEAM_DMG;
                    dmg = Math.max(0, dmg);
                    
                    if(otherPlayers[hitId].mesh.userData.isBlocking) {
                        dmg *= (1.0 - GAME_CONFIG.SPELL_PARAMS.BLOCK_MITIGATION);
                        dmg = Math.max(0, dmg);
                        createFloatingText(enemyFound.position.clone().add(new THREE.Vector3(0,10,0)), "BLOCK", "#aaa");
                    } else {
                        createFloatingText(enemyFound.position.clone().add(new THREE.Vector3(0,10,0)), `-${Math.round(dmg)}`, "#ff3333");
                    }
                    socket.emit('playerHit', { 
                        damage: Math.max(0, dmg), 
                        targetId: hitId,
                        hitPosition: otherPlayers[hitId].mesh.position.clone()
                    }); 
                    socket.emit('playerAttack', { type: 'spikes', origin: hitPoint, direction: new THREE.Vector3() });
                }
                addToLog("Stone Spikes activated!", "spell-cast"); 
                playSound('hit');
            }
        }

        function spawnProjectile(type) {
            // Stamina check for bow
            if (type === 5 && playerStats.stamina < GAME_CONFIG.SPELL_PARAMS.ARROW_COST) {
                addToLog("Insufficient Stamina!", "#555");
                return;
            }
            
            if (type === 5) {
                playerStats.stamina -= GAME_CONFIG.SPELL_PARAMS.ARROW_COST;
            }
            
            let geo, speed, color, radius;
            if (type === 1) { geo = new THREE.SphereGeometry(1.0); color = 0x00ffff; speed = GAME_CONFIG.PHYSICS.MISSILE_SPEED; radius = 1.0; } 
            else if (type === 2) { geo = new THREE.SphereGeometry(1.8); color = 0xffffff; speed = GAME_CONFIG.PHYSICS.PUSH_SPEED; radius = 1.8; } 
            else if (type === 3) { geo = new THREE.SphereGeometry(3.0); color = 0xff6600; speed = GAME_CONFIG.PHYSICS.FIREBALL_SPEED; radius = 3.0; }
            else if (type === 5) { 
                geo = new THREE.CylinderGeometry(0.1, 0.1, 4); 
                // RUOTA LA GEOMETRIA PER ALLINEARLA ALL'ASSE Z (Orizzontale)
                geo.rotateX(-Math.PI / 2); 
                color = 0x8B4513; speed = GAME_CONFIG.PHYSICS.ARROW_SPEED; radius = 0.5; 
            } 
            
            const proj = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
            
            let spawnPos;
            const camDir = new THREE.Vector3(); 
            camera.getWorldDirection(camDir);
            
            if(type === 5 && weaponMode === 'bow') {
                 // Freccia parte dalla camera
                 spawnPos = camera.position.clone().add(camDir.clone().multiplyScalar(3));
            } else {
                 // Spell parte dalla punta dello staff
                 spawnPos = getStaffTip();
                 
                 // Fireball: spawn più alto per evitare clipping con il player
                 if (type === 3) {
                    spawnPos.y += 1.5;
                 }
                 
                 // Se il player è troppo vicino a un nemico, sposta la spawn più avanti
                 let minEnemyDist = Infinity;
                 Object.values(otherPlayers).forEach(op => {
                    const distToEnemy = camera.position.distanceTo(op.mesh.position);
                    if (distToEnemy < minEnemyDist) minEnemyDist = distToEnemy;
                 });
                 
                 // Se il nemico è a < 15 unità, sposta la spawn più avanti per evitare clip
                 if (minEnemyDist < 15) {
                    spawnPos = spawnPos.add(camDir.clone().multiplyScalar(5));
                 }
            }

            const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
            const hits = raycaster.intersectObjects([...obstacles], true);
            let targetPoint;
            if(hits.length > 0) { targetPoint = hits[0].point; } else { const camDir2 = new THREE.Vector3(); camera.getWorldDirection(camDir2); targetPoint = camera.position.clone().add(camDir2.multiplyScalar(100)); }
            
            // Calcola la direzione dal punto di spawn al target
            let velocityDir = new THREE.Vector3().subVectors(targetPoint, spawnPos).normalize();
            
            // FIREBALL: add gentle upward component, let gravity pull down fast
            if (type === 3) {
                velocityDir.y += 0.15; // Gentle lift, steep descent from gravity
                velocityDir.normalize();
            }
            
            proj.position.copy(spawnPos);
            
            if(type === 5) proj.lookAt(targetPoint);
            else { const light = new THREE.PointLight(color, 1, 30); proj.add(light); }

            proj.userData = { velocity: velocityDir.multiplyScalar(speed), life: (type===5 ? 5.0 : 2.0), type: type, isMine: true, radius: radius };
            scene.add(proj); projectiles.push(proj);
        }

        function spawnEnemyProjectile(startPos, direction, type) {
            let color = 0xff0000; let speed = 900; let radius = 1.0;
            let geo;
            if (type === 1) { geo = new THREE.SphereGeometry(1.0); color = 0x00ffff; speed = GAME_CONFIG.PHYSICS.MISSILE_SPEED; radius = 1.0; } 
            else if (type === 2) { geo = new THREE.SphereGeometry(1.8); color = 0xffffff; speed = GAME_CONFIG.PHYSICS.PUSH_SPEED; radius = 1.8; } 
            else if (type === 3) { geo = new THREE.SphereGeometry(3.0); color = 0xff6600; speed = GAME_CONFIG.PHYSICS.FIREBALL_SPEED; radius = 3.0; }
            else if (type === 5) { 
                geo = new THREE.CylinderGeometry(0.1, 0.1, 4); 
                geo.rotateX(-Math.PI / 2); 
                color = 0x8B4513; speed = GAME_CONFIG.PHYSICS.ARROW_SPEED; radius = 0.5;
            }
            
            const proj = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
            proj.position.copy(startPos);
            let dirVec = new THREE.Vector3(direction.x, direction.y, direction.z).normalize();
            
            // FIREBALL: add gentle upward component, let gravity pull down fast
            if (type === 3) {
                dirVec.y += 0.15; // Gentle lift, steep descent from gravity
                dirVec.normalize();
            }
            
            if(type === 5) {
                proj.lookAt(proj.position.clone().add(dirVec));
            } else {
                const light = new THREE.PointLight(color, 1, 20); proj.add(light);
            }

            proj.userData = { velocity: dirVec.multiplyScalar(speed), life: (type===5 ? 5.0 : 3.0), type: type, isMine: false, radius: radius };
            scene.add(proj); projectiles.push(proj); playSound(type === 3 ? 'shoot_fire' : 'shoot_bolt');
        }

function updateProjectiles(delta) {
            const opponentMeshes = Object.values(otherPlayers).map(p => p.mesh);
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i]; 
                const move = p.userData.velocity.clone().multiplyScalar(delta);
                
                if (move.lengthSq() < 0.000001) continue; 

                const nextPos = p.position.clone().add(move);
                let hit = false, hitPoint = p.position.clone();
                let hitTarget = null;
                
                if (p.userData.isMine) {
                    // Controlla collisione con altri giocatori - RAGGIO DINAMICO PER PRIMA PERSONA
                    let collisionRadius = 8.0;
                    
                    // Calcola distanza minima da tutti i nemici
                    let minEnemyDist = Infinity;
                    Object.values(otherPlayers).forEach(op => {
                        const distToEnemy = camera.position.distanceTo(op.mesh.position);
                        if (distToEnemy < minEnemyDist) minEnemyDist = distToEnemy;
                    });
                    
                    // Se il player è troppo vicino a un nemico, aumenta il raggio di collisione
                    if (minEnemyDist < 15) {
                        collisionRadius = 12.0;
                    }
                    
                    Object.values(otherPlayers).forEach(op => {
                        const distToHit = p.position.distanceTo(op.mesh.position);
                        const dy = p.position.y - op.mesh.position.y;
                        if (distToHit < collisionRadius && dy > -5 && dy < 20.0) {
                            hit = true; hitTarget = op.mesh; hitPoint = p.position.clone();
                        }
                    });
                    
                    // Controlla collisione con il mostro IA
                    if (!hit && isPvEMode && aiMonster && aiMonster.state !== 'dead') {
                        const dx = p.position.x - aiMonster.mesh.position.x;
                        const dz = p.position.z - aiMonster.mesh.position.z;
                        const distXZ = Math.sqrt(dx*dx + dz*dz);
                        const dy = p.position.y - aiMonster.mesh.position.y;
                        if (distXZ < 10.0 && dy > 0 && dy < 20.0) {
                            hit = true; 
                            hitTarget = aiMonster.mesh;
                            hitPoint = p.position.clone();
                        }
                    }

                    if (!hit) {
                        obstacleRaycaster.set(p.position, p.userData.velocity.clone().normalize());
                        obstacleRaycaster.far = move.length() + 0.1;
                        const intersects = obstacleRaycaster.intersectObjects([...obstacles], true);
                        if (intersects.length > 0) { hit = true; hitPoint = intersects[0].point; }
                    }
                        
                    if (hitTarget) {
                        let dmg = 0;
                        if (p.userData.type === 1) dmg = GAME_CONFIG.SPELL_PARAMS.MISSILE_DMG; 
                        else if (p.userData.type === 3) dmg = GAME_CONFIG.SPELL_PARAMS.FIREBALL_DMG;
                        else if (p.userData.type === 2) dmg = GAME_CONFIG.SPELL_PARAMS.PUSH_DMG;
                        else if (p.userData.type === 5) dmg = GAME_CONFIG.SPELL_PARAMS.ARROW_DMG; 

                        // Assicurati che il danno sia sempre positivo
                        dmg = Math.max(0, dmg);

                        // Controlla se il bersaglio è un giocatore o il mostro IA
                        const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key].mesh === hitTarget);
                        const isMonsterTarget = hitTarget === aiMonster?.mesh;
                        
                        if (isMonsterTarget) {
                            // Hit the AI monster
                            damageAIMonster(dmg);
                            createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0, 15, 0)), `-${dmg}`, "#ff9999");
                            addToLog(`Hit the monster for ${dmg} damage!`, "dmg-dealt");
                        } else if (targetId) {
                            // Hit another player
                            let mitigatedDmg = dmg;
                            if(otherPlayers[targetId].mesh.userData.isBlocking) {
                                 mitigatedDmg *= (1.0 - GAME_CONFIG.SPELL_PARAMS.BLOCK_MITIGATION);
                                 mitigatedDmg = Math.max(0, mitigatedDmg); // Assicurati che sia positivo anche dopo mitigazione
                                 createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0,10,0)), "BLOCK", "#aaa");
                            } else {
                                 createFloatingText(hitTarget.position.clone().add(new THREE.Vector3(0,10,0)), `-${Math.round(mitigatedDmg)}`, "#ff3333");
                            }

                            if (socket) {
                                if (p.userData.type === 2) { 
                                    spawnExplosionVisual(hitPoint, 0xffffff, GAME_CONFIG.SPELL_PARAMS.PUSH_VISUAL_RADIUS);
                                    socket.emit('playerPushed', { targetId: targetId, forceY: GAME_CONFIG.SPELL_PARAMS.PUSH_UP_FORCE, forceVec: new THREE.Vector3().subVectors(otherPlayers[targetId].mesh.position, hitPoint).normalize().multiplyScalar(GAME_CONFIG.PHYSICS.PUSH_FORCE), damage: Math.max(0, mitigatedDmg) });
                                    checkShockwaveAoE(hitPoint);
                                } else if (p.userData.type === 3) { 
                                    spawnExplosionVisual(hitPoint, 0xff4500, GAME_CONFIG.SPELL_PARAMS.FIREBALL_RADIUS); 
                                    socket.emit('playerPushed', { targetId: targetId, forceY: GAME_CONFIG.SPELL_PARAMS.FIREBALL_UP_FORCE, damage: Math.max(0, mitigatedDmg) });
                                    checkSplashDamage(hitPoint, GAME_CONFIG.SPELL_PARAMS.FIREBALL_RADIUS, 5, false);
                                    addToLog(`Hit ${otherPlayers[targetId].username} with Fireball!`, "dmg-dealt");
                                } else { 
                                    socket.emit('playerHit', { 
                                        damage: Math.max(0, mitigatedDmg), 
                                        targetId: targetId,
                                        hitPosition: otherPlayers[targetId].mesh.position.clone()
                                    });
                                }
                            }
                        }
                    }
                } 
                else {
                    const dx = p.position.x - playerMesh.position.x;
                    const dz = p.position.z - playerMesh.position.z;
                    const distXZ = Math.sqrt(dx*dx + dz*dz);
                    const dy = p.position.y - playerMesh.position.y;
                    if (distXZ < 8.0 && dy > 0 && dy < 15.0) {
                         hit = true; hitPoint = playerMesh.position;
                         playSound('hit');
                    }
                }

                if(!hit && nextPos.y <= 0) { 
                    hit=true; hitPoint.y = 0; p.position.y = 0;
                    if (p.userData.isMine) {
                        if (p.userData.type === 2) {
                            spawnExplosionVisual(hitPoint, 0xffffff, GAME_CONFIG.SPELL_PARAMS.PUSH_VISUAL_RADIUS); 
                            checkShockwaveAoE(hitPoint);
                        } else if (p.userData.type === 3) { 
                            spawnExplosionVisual(hitPoint, 0xff4500, GAME_CONFIG.SPELL_PARAMS.FIREBALL_RADIUS); 
                            checkSplashDamage(hitPoint, GAME_CONFIG.SPELL_PARAMS.FIREBALL_RADIUS, 5, false);
                        }
                    }
                }
                
                if (hit) { 
                    if(p.userData.type !== 2 && p.userData.type !== 5) spawnExplosionVisual(hitPoint, p.material.color.getHex(), p.userData.type === 3 ? GAME_CONFIG.SPELL_PARAMS.FIREBALL_RADIUS : 5); 
                    scene.remove(p); projectiles.splice(i, 1); 
                } else { 
                    p.position.add(move); p.userData.life -= delta; 
                    
                    let gravity = GAME_CONFIG.PHYSICS.GRAVITY;
                    if (p.userData.type === 5) gravity = GAME_CONFIG.PHYSICS.ARROW_GRAVITY; // Freccia
                    else if (p.userData.type === 1) gravity = GAME_CONFIG.PHYSICS.MISSILE_GRAVITY; // Bolt
                    else if (p.userData.type === 2) gravity = GAME_CONFIG.PHYSICS.PUSH_GRAVITY; // Begone
                    else if (p.userData.type === 3) gravity = GAME_CONFIG.PHYSICS.FIREBALL_GRAVITY; // Fireball
                    p.userData.velocity.y -= gravity * delta;
                    
                    if (p.userData.type === 5) p.lookAt(p.position.clone().add(p.userData.velocity)); 
                    if (p.userData.life <= 0) { scene.remove(p); projectiles.splice(i, 1); }
                }
            }
        }

        function checkShockwaveAoE(origin) {
            const distToMe = playerMesh.position.distanceTo(origin);
            if (distToMe < GAME_CONFIG.SPELL_PARAMS.PUSH_RADIUS) {
                const dir = new THREE.Vector3().subVectors(playerMesh.position, origin).normalize();
                const forceVec = dir.multiplyScalar(GAME_CONFIG.PHYSICS.PUSH_FORCE);
                velocity.add(forceVec);
                velocity.y += GAME_CONFIG.SPELL_PARAMS.PUSH_UP_FORCE;
                canJump = false; playerStats.isFalling = true; playerMesh.position.y += 0.5;
                addToLog("Knocked back by wave!", "spell-cast"); playSound('jump');
            }

            Object.values(otherPlayers).forEach(op => {
                const distToEnemy = op.mesh.position.distanceTo(origin);
                if (distToEnemy < GAME_CONFIG.SPELL_PARAMS.PUSH_RADIUS) {
                    const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key] === op);
                    let finalDmg = 10; 
                    if(op.mesh.userData.isBlocking) finalDmg *= (1.0 - GAME_CONFIG.SPELL_PARAMS.BLOCK_MITIGATION); 
                    const dir = new THREE.Vector3().subVectors(op.mesh.position, origin).normalize();
                    const forceVec = dir.multiplyScalar(GAME_CONFIG.PHYSICS.PUSH_FORCE);
                    forceVec.y = GAME_CONFIG.SPELL_PARAMS.PUSH_UP_FORCE; 
                    // NON applicare danno lato client - il server lo farà
                    socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: finalDmg });
                }
            });
        }

        function checkSplashDamage(origin, radius, damage, pushBack) {
            // Assicurati che il danno sia sempre positivo
            const safeDamage = Math.max(0, damage);
            
            Object.values(otherPlayers).forEach(op => {
                if (op.mesh.position.distanceTo(origin) < radius) {
                    const targetId = Object.keys(otherPlayers).find(key => otherPlayers[key] === op);
                    let finalDmg = safeDamage;
                    if(op.mesh.userData.isBlocking) {
                        finalDmg *= (1.0 - GAME_CONFIG.SPELL_PARAMS.BLOCK_MITIGATION);
                        createFloatingText(op.mesh.position.clone().add(new THREE.Vector3(3,5,0)), "BLOCK", "#aaa");
                    } else {
                        // Il danno deve SEMPRE essere positivo - mostralo come -${damageValue}
                        createFloatingText(op.mesh.position.clone().add(new THREE.Vector3(3,5,0)), `-${Math.round(Math.max(0, finalDmg))}`, "#ff3333");
                    }
                    if (pushBack) {
                         const dir = new THREE.Vector3().subVectors(op.mesh.position, origin).normalize();
                         const forceVec = dir.multiplyScalar(GAME_CONFIG.PHYSICS.PUSH_FORCE * 0.5); 
                         forceVec.y = 100;
                         socket.emit('playerPushed', { targetId: targetId, forceVec: forceVec, damage: Math.max(0, finalDmg) });
                    } else {
                         socket.emit('playerHit', { 
                             damage: Math.max(0, finalDmg), 
                             targetId: targetId,
                             hitPosition: otherPlayers[targetId].mesh.position.clone()
                         });
                    }
                }
            });
        }

        function swingSword() {
            if (playerStats.stamina < GAME_CONFIG.SPELL_PARAMS.MELEE_STAMINA_COST) {
                addToLog("Insufficient Stamina!", "#555");
                return;
            }
            
            playerStats.stamina -= GAME_CONFIG.SPELL_PARAMS.MELEE_STAMINA_COST;
            isAttacking = true; attackTimer = 0;
            if(swordContainer.userData.trail) { swordContainer.userData.trail.material.opacity = 0.8; setTimeout(() => swordContainer.userData.trail.material.opacity = 0, 200); }
            playSound('swing_heavy');
            
            // Broadcast melee attack to other players for animation
            if (socket) {
                socket.emit('playerAttack', { type: 'melee', origin: playerMesh.position.clone(), direction: new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0,euler.y,0)) });
            }
            
            const origin = playerMesh.position.clone(); 
            const forward = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0,euler.y,0));
            Object.entries(otherPlayers).forEach(([id, p]) => {
                const dir = new THREE.Vector3().subVectors(p.mesh.position, origin);
                if (dir.length() < GAME_CONFIG.SPELL_PARAMS.MELEE_RANGE && forward.angleTo(dir.normalize()) < Math.PI/2) {
                    let dmg = GAME_CONFIG.SPELL_PARAMS.MELEE_DMG;
                    // Controlla se il nemico sta bloccando
                    const isBlocking = p.mesh.userData.isBlocking || false;
                    if(isBlocking) {
                        dmg *= (1.0 - GAME_CONFIG.SPELL_PARAMS.BLOCK_MITIGATION); 
                        createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0,10,0)), "BLOCK", "#aaa");
                    } else {
                        createFloatingText(p.mesh.position.clone().add(new THREE.Vector3(0,10,0)), `-${Math.round(dmg)}`, "#ff3333");
                    }
                    if (socket) {
                        // Invia playerHit al server per il danno
                        socket.emit('playerHit', { 
                            damage: Math.max(0, dmg), 
                            targetId: id,
                            hitPosition: p.mesh.position.clone()
                        });
                    }
                    addToLog(`Hit ${p.username} with Sword! -${Math.round(dmg)}`, "dmg-dealt");
                }
            });
        }

