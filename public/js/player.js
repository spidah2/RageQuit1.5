// player.js - autogenerated module from original game.js

function createHelmet(parent) {
             const helmetGroup = new THREE.Group();
             const helmGeo = new THREE.BoxGeometry(3.2, 4.2, 3.4);
             const helmMat = new THREE.MeshStandardMaterial({color: 0x555555, metalness: 0.8, roughness: 0.2});
             const helm = new THREE.Mesh(helmGeo, helmMat);
             helmetGroup.add(helm);
             const visorGeo = new THREE.BoxGeometry(2.8, 0.5, 3.6);
             const visorMat = new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.9});
             const visor = new THREE.Mesh(visorGeo, visorMat);
             visor.position.set(0, 0.2, -0.2);
             helmetGroup.add(visor);
             const crestGeo = new THREE.BoxGeometry(0.4, 1.5, 3.8);
             const crestMat = new THREE.MeshLambertMaterial({color: 0xc0392b});
             const crest = new THREE.Mesh(crestGeo, crestMat);
             crest.position.y = 2.2;
             helmetGroup.add(crest);
             helmetGroup.position.y = 8.5;
             parent.add(helmetGroup);
             return helmetGroup;
        }

function createPlayer() {
    // Defensive: se il modello esiste già, rimuovilo
    if (typeof playerMesh !== 'undefined' && playerMesh) {
        try { scene.remove(playerMesh); } catch (e) {}
        playerMesh = null;
    }

    const teamColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;
    console.log('[CREATE PLAYER] Using team color:', teamColor.toString(16));

    // LOGICA + RENDERING sono DISACCOPPIATI:
    // 1. AssetManager crea la GRAFICA (mesh 3D)
    // 2. player.js gestisce la LOGICA (HP, velocità, posizione)
    // 3. Collegamento: playerMesh = modello visivo, playerStats = dati logica

    // Richiedi il modello grafico all'AssetManager
    if (typeof assetManager !== 'undefined' && assetManager) {
        playerMesh = assetManager.getPlayerMesh(teamColor);
        logGame('[CREATE PLAYER] Using AssetManager', 'GAME');
    } else {
        // Fallback se AssetManager non è disponibile
        logGame('[CREATE PLAYER] AssetManager not available, creating basic mesh', 'GAME', 'WARNING');
        playerMesh = new THREE.Group();
        const torso = new THREE.Mesh(
            new THREE.BoxGeometry(4.5, 6.5, 3),
            new THREE.MeshLambertMaterial({ color: teamColor, emissive: teamColor })
        );
        torso.position.y = 3.5;
        playerMesh.add(torso);
    }

    // Posiziona il giocatore alla spawn corretta
    const spawnPos = getSpawnPosition ? getSpawnPosition() : new THREE.Vector3(0, 6, 0);
    playerMesh.position.copy(spawnPos);

    // Aggiungi alla scena
    scene.add(playerMesh);
}

function updatePlayerColor() {
    if (!playerMesh) return;

    const currentColor = typeof myTeamColor !== 'undefined' ? myTeamColor : 0x2c3e50;
    console.log('[PLAYER COLOR] Updating player color to:', currentColor.toString(16));

    // Usa AssetManager se disponibile
    if (typeof assetManager !== 'undefined' && assetManager && typeof assetManager.updatePlayerColor === 'function') {
        assetManager.updatePlayerColor(playerMesh, currentColor);
    } else {
        // Fallback: logica manuale
        playerMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                const isMetalPiece = (child.material.color && child.material.color.getHex() === 0x95a5a6) ||
                    (child.material.color && child.material.color.getHex() === 0x555555) ||
                    (child.material.color && child.material.color.getHex() === 0x111111);

                if (!isMetalPiece && child.material.color) {
                    child.material.color.setHex(currentColor);
                    if (child.material.emissive) {
                        child.material.emissive.setHex(currentColor);
                    }
                    child.material.needsUpdate = true;
                }
            }
        });
    }
}

function createSword() {
            swordContainer = new THREE.Group();
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 18, 0.2), new THREE.MeshStandardMaterial({color:0xecf0f1, metalness:0.9})); blade.position.y=10; swordContainer.add(blade);
            const guard = new THREE.Mesh(new THREE.BoxGeometry(6, 0.8, 0.8), new THREE.MeshStandardMaterial({color:0xf39c12})); guard.position.y=1; swordContainer.add(guard);
            const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 4), new THREE.MeshStandardMaterial({color:0x5a3a22})); hilt.position.y=-1.5; swordContainer.add(hilt);
            
            swordContainer.position.set(0,-5,0.5); 
            swordContainer.rotation.x = -Math.PI/2; 
            swordContainer.rotation.y = 0; 
            swordContainer.rotation.z = Math.PI/2; 
            
            swordContainer.visible=false; playerLimbs.armR.add(swordContainer);
            const trailGeo = new THREE.RingGeometry(8, 12, 32, 1, 0, Math.PI);
            const trailMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
            const trail = new THREE.Mesh(trailGeo, trailMat); trail.rotation.x = -Math.PI/2; trail.position.y = 10; swordContainer.add(trail); swordContainer.userData.trail = trail;
        }

function createStaff() {
            staffContainer = new THREE.Group();
            staffContainer.add(new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.3,22), new THREE.MeshStandardMaterial({color:0x3e2723}))).position.y=6;
            const head = new THREE.Mesh(new THREE.TorusGeometry(1.5,0.3,8,20), new THREE.MeshStandardMaterial({color:0xffd700})); head.position.y=17; head.rotation.y=Math.PI/2; staffContainer.add(head);
            const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.8), new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.9})); gem.position.y=17; staffContainer.add(gem);
            staffContainer.userData.gem = gem; staffContainer.position.set(0,-4,0); staffContainer.rotation.x=-Math.PI/6; playerLimbs.armR.add(staffContainer);
        }

function createBow() {
            bowContainer = new THREE.Group();
            const bowCurve = new THREE.Mesh(new THREE.TorusGeometry(3, 0.2, 8, 12, Math.PI), new THREE.MeshStandardMaterial({color: 0x8B4513}));
            bowCurve.rotation.z = -Math.PI/2;
            bowContainer.add(bowCurve);
            const stringGeo = new THREE.CylinderGeometry(0.05, 0.05, 6);
            const string = new THREE.Mesh(stringGeo, new THREE.MeshBasicMaterial({color: 0xffffff}));
            string.rotation.z = -Math.PI/2;
            string.position.x = -0.5;
            bowContainer.add(string);
            
            bowContainer.position.set(0, -2, 0);
            bowContainer.visible = false;
            playerLimbs.armL.add(bowContainer);
        }

function createShield() {
            shieldMesh = new THREE.Mesh(new THREE.BoxGeometry(4, 8, 1), new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.6, side: THREE.DoubleSide }));
            shieldMesh.position.set(3, -2, -0.5); // Spostato in avanti per evitare di clippare sotto il body
            shieldMesh.rotation.y = -Math.PI/2;
            shieldMesh.visible = false;
            playerLimbs.armL.add(shieldMesh);
        }

function spawnParticles(pos, color, count, speedBase, size, isGibs) {
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for(let i=0; i<count; i++) {
                const particleSize = isGibs ? (size * (0.5 + random() * 0.5)) : size;
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(particleSize,particleSize,particleSize), mat);
                mesh.position.copy(pos); mesh.position.add(new THREE.Vector3(random()-0.5, random()-0.5, random()-0.5).multiplyScalar(2));
                scene.add(mesh);
                // Ridotto tempo di vita: gibs 2 secondi, particelle normali 0.5 secondi
                const lifeTime = isGibs ? 2.0 : 0.5;
                particles.push({ mesh: mesh, velocity: new THREE.Vector3(random()-0.5, random()*0.5+0.2, random()-0.5).normalize().multiplyScalar(speedBase*(random()+0.5)), life: lifeTime, maxLife: lifeTime, isGib: isGibs });
            }
        }

function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i]; p.life -= delta; p.velocity.y -= 50.0 * delta; 
                p.mesh.position.addScaledVector(p.velocity, delta); p.mesh.rotation.x+=delta*5;
                const scale = p.life / p.maxLife;
                p.mesh.scale.setScalar(scale);
                // Le gibs a terra spariscono gradualmente tramite fade
                if (p.mesh.position.y < 0.5) { 
                    p.mesh.position.y = 0.5; 
                    if(p.isGib) { 
                        p.velocity.y*=-0.5; 
                        p.velocity.x*=0.8; 
                        p.velocity.z*=0.8;
                        // Fade out più rapido quando sono a terra
                        p.life -= delta * 2;
                    } else {
                        p.velocity.set(0,0,0);
                    }
                }
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }
        }

function createFloatingText(pos, text, color) {
            const el = document.createElement('div'); el.className = 'floating-text'; el.innerText = text; el.style.color = color; document.body.appendChild(el);
            updateFloatingElement(el, pos); floatingTexts.push({ element: el, pos: pos.clone(), life: 1.0 });
        }

function updateFloatingTexts(delta) {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i]; ft.life -= delta; ft.pos.y += 5 * delta; updateFloatingElement(ft.element, ft.pos);
                if (ft.life <= 0) { ft.element.remove(); floatingTexts.splice(i, 1); }
            }
        }

function updateFloatingElement(el, pos) {
            const screenPos = pos.clone().project(camera);
            const x = (screenPos.x * .5 + .5) * window.innerWidth; const y = (-(screenPos.y * .5) + .5) * window.innerHeight;
            el.style.left = x + 'px'; el.style.top = y + 'px';
        }

function spawnExplosionVisual(pos, color, radius) {
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6, wireframe: true });
            const sphere = new THREE.Mesh(geometry, material); sphere.position.copy(pos); scene.add(sphere);
            const light = new THREE.PointLight(color, 2, radius * 3); light.position.copy(pos); scene.add(light);
            let scale = 1.0;
            const expand = setInterval(() => {
                scale += 0.2; sphere.scale.setScalar(scale); sphere.material.opacity -= 0.05;
                if (sphere.material.opacity <= 0) { clearInterval(expand); scene.remove(sphere); scene.remove(light); geometry.dispose(); material.dispose(); }
            }, 30);
            setTimeout(() => { if(sphere.parent) scene.remove(sphere); if(light.parent) scene.remove(light); }, 1000);
        }

function flashScreen(colorStr) { const flash = document.getElementById('screen-flash'); flash.style.backgroundColor = colorStr; flash.style.opacity = 0.4; setTimeout(() => { flash.style.opacity = 0; }, 150); }

function spawnGlowEffect(color) {
            let spawnPos;
            if(weaponMode === 'ranged' || weaponMode === 'bow') {
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                spawnPos = camera.position.clone().add(camDir.multiplyScalar(3));
                spawnParticles(spawnPos, color, 10, 5, 0.2, false);
            } else {
                spawnPos = playerMesh.position.clone().add(new THREE.Vector3(0,5,0));
                spawnParticles(playerMesh.position, color, 15, 15, 0.3, false);
            }
            const light = new THREE.PointLight(color, 8, 30); light.position.copy(spawnPos); scene.add(light);
            let intensity = 8;
            const fade = setInterval(() => { intensity -= 0.4; light.intensity = intensity; if (intensity <= 0) { clearInterval(fade); scene.remove(light); } }, 50);
        }

function updateAnimations(delta) {
            const time = performance.now() * 0.005;
            const isMoving = moveForward || moveBackward || moveLeft || moveRight;
            
            if (playerStats.isDead) { playerMesh.position.y = 6; return; }
            
            const neutralArmY = 8.0; 

            if (weaponMode === 'ranged') {
                playerLimbs.armR.position.y = 6.0; playerLimbs.armL.position.y = 6.0;
                playerLimbs.armR.rotation.x = -Math.PI / 2 + Math.sin(time) * 0.05 - (isAttacking ? Math.sin(attackTimer * 2) * 0.5 : 0); 
                playerLimbs.armR.rotation.z = 0;
                if(staffContainer.userData.gem) staffContainer.userData.gem.scale.setScalar(isAttacking ? 1.5 : 1.0);
                playerLimbs.armL.rotation.x = -0.5 + Math.cos(time) * 0.1;
                playerLimbs.legL.rotation.x = isMoving ? Math.sin(time*3)*0.8 : 0; playerLimbs.legR.rotation.x = isMoving ? -Math.sin(time*3)*0.8 : 0;
            } else if (weaponMode === 'bow') {
                playerLimbs.armR.position.y = 6.0; playerLimbs.armL.position.y = 6.0;
                // Braccio sx tiene l'arco (teso in avanti, ma spostato al centro per visuale)
                playerLimbs.armL.rotation.x = -Math.PI / 2;
                playerLimbs.armL.rotation.y = -0.2; // slight adjustment
                playerLimbs.armL.position.x = -0.5; // Center more
                playerLimbs.armL.position.y = 5.5; // Lower slightly
                playerLimbs.armL.position.z = 1.5; // Push forward
                
                if(castingState.active && castingState.type === 'bow_shot') {
                     playerLimbs.armR.rotation.x = -Math.PI / 2;
                     playerLimbs.armR.position.z = -Math.sin(castingState.timer * 2) * 1.5 + 1; // Tira indietro
                } else {
                     playerLimbs.armR.rotation.x = -0.5;
                     playerLimbs.armR.position.z = 0;
                }
                playerLimbs.legL.rotation.x = isMoving ? Math.sin(time*3)*0.8 : 0; playerLimbs.legR.rotation.x = isMoving ? -Math.sin(time*3)*0.8 : 0;
            } else {
                // Reset positions for melee
                playerLimbs.armL.position.x = -3; playerLimbs.armL.position.z = 0;
                
                playerLimbs.armR.position.y = neutralArmY; playerLimbs.armL.position.y = neutralArmY;
                if (!canJump && !playerStats.isFalling) { 
                    playerLimbs.legL.rotation.x = 0.8; playerLimbs.legR.rotation.x = 0.8; playerLimbs.armL.rotation.x = -0.8; 
                    if(!isAttacking) playerLimbs.armR.rotation.x = -0.8; 
                } else if (isMoving) { 
                    const isSprintingActive = isSprinting && playerStats.stamina > 0; const speedMulti = isSprintingActive ? 8 : 4;
                    const armAmp = isSprintingActive ? 1.2 : 0.6; const legAmp = isSprintingActive ? 1.4 : 0.8; const angle = Math.sin(time * speedMulti);
                    playerLimbs.legL.rotation.x = angle * legAmp; playerLimbs.legR.rotation.x = -angle * legAmp; 
                    if(playerLimbs.bootL) playerLimbs.bootL.rotation.x = -playerLimbs.legL.rotation.x * 0.6;
                    if(playerLimbs.bootR) playerLimbs.bootR.rotation.x = -playerLimbs.legR.rotation.x * 0.6;
                    if (!isAttacking && !isWhirlwinding && !isBlocking) { 
                        playerLimbs.armL.rotation.x = -angle * armAmp; playerLimbs.armR.rotation.x = angle * armAmp; 
                    }
                    playerLimbs.torso.rotation.x = isSprintingActive ? 0.3 : 0.1; 
                } else {
                    playerLimbs.legL.rotation.x = 0; playerLimbs.legR.rotation.x = 0; 
                    if(playerLimbs.bootL) playerLimbs.bootL.rotation.x = 0;
                    if(playerLimbs.bootR) playerLimbs.bootR.rotation.x = 0;
                    if(!isAttacking && !isWhirlwinding && !isBlocking) { 
                        playerLimbs.armL.rotation.x = Math.sin(time)*0.05; playerLimbs.armR.rotation.x = -0.1;
                    }
                    playerLimbs.torso.rotation.x = 0;
                }
            }

            if (isBlocking) {
                playerLimbs.armL.rotation.set(-Math.PI/2, 0, Math.PI/2);
                shieldMesh.visible = true;
                // Aggiorna il colore dello scudo al colore della squadra
                if (typeof myTeamColor !== 'undefined') {
                    shieldMesh.material.color.setHex(myTeamColor);
                }
            } else {
                playerLimbs.armL.rotation.z = 0;
                shieldMesh.visible = false;
            }
            
            Object.values(otherPlayers).forEach(p => {
                const mesh = p.mesh;
                if (p.isDead) return; 
                const enemyNeutralArmY = p.mesh.userData.weaponMode === 'melee' ? neutralArmY : 6.0;
                p.limbs.armR.position.y = enemyNeutralArmY; p.limbs.armL.position.y = enemyNeutralArmY;
                const distMoved = mesh.position.distanceTo(p.lastStepPos || mesh.position);
                if (distMoved > 4.0) { playSound('step', mesh.position); p.lastStepPos.copy(mesh.position); }
                if(mesh.userData.targetPos) mesh.position.lerp(mesh.userData.targetPos, 0.3); 
                if(mesh.userData.targetRot) { mesh.rotation.set(mesh.userData.targetRot.x, mesh.userData.targetRot.y, mesh.userData.targetRot.z); }
                const state = mesh.userData.animState; const limbs = p.limbs; let isEnemyAttacking = false;
                if (mesh.userData.isWhirlwinding) {
                    mesh.rotation.y += delta * 20; limbs.armR.rotation.x = -Math.PI/2; limbs.armL.rotation.x = -Math.PI/2; return;
                }
                if (mesh.userData.isAttacking) {
                    mesh.userData.attackTimer += delta * 15;
                    if (mesh.userData.attackTimer > Math.PI) { mesh.userData.isAttacking = false; mesh.userData.attackTimer = 0; } else {
                        isEnemyAttacking = true; const progress = mesh.userData.attackTimer / Math.PI; limbs.armR.rotation.x = -Math.PI/4 - Math.sin(progress * Math.PI) * 1.5; 
                    }
                }
                if (!isEnemyAttacking) {
                    if (mesh.userData.isBlocking) {
                        limbs.armL.rotation.set(-Math.PI/2, 0, Math.PI/2);
                    } else if (state === 'run' || state === 'walk') {
                        const speed = state === 'run' ? 8 : 4; const angle = Math.sin(time * speed);
                        limbs.legL.rotation.x = angle; limbs.legR.rotation.x = -angle;
                        if(limbs.bootL) limbs.bootL.rotation.x = -limbs.legL.rotation.x * 0.6;
                        if(limbs.bootR) limbs.bootR.rotation.x = -limbs.legR.rotation.x * 0.6;
                        limbs.armL.rotation.x = -angle; limbs.armR.rotation.x = angle;
                        if (p.mesh.userData.weaponMode === 'bow') limbs.armL.rotation.x = -Math.PI/2; // Enemy bow pose
                    } else {
                        limbs.legL.rotation.x = 0; limbs.legR.rotation.x = 0;
                        if(limbs.bootL) limbs.bootL.rotation.x = 0; if(limbs.bootR) limbs.bootR.rotation.x = 0;
                        limbs.armL.rotation.x = Math.sin(time)*0.05; limbs.armR.rotation.x = -Math.sin(time)*0.05;
                        if (p.mesh.userData.weaponMode === 'bow') limbs.armL.rotation.x = -Math.PI/2; // Enemy bow pose
                    }
                }
                if(mesh.userData.hpBar) mesh.userData.hpBar.parent.lookAt(camera.position);
            });
        }

function toggleWeaponManual() { toggleWeapon(); }

function toggleWeapon(force) {
            // Logic updated: Q cycles Melee/Ranged, E selects Bow
            // This function is now mainly for visual updates based on current `weaponMode`
            
            const isMelee = weaponMode === 'melee';
            const isRanged = weaponMode === 'ranged';
            const isBow = weaponMode === 'bow';
            
            swordContainer.visible = isMelee; 
            staffContainer.visible = isRanged;
            bowContainer.visible = isBow;
            
            // Hide body parts in first-person ranged/bow mode, show only arms
            playerMesh.visible = isMelee;
            if (isRanged || isBow) {
                stopBlocking();
                euler.x = 0;
                // Hide body but keep arms visible
                if(playerLimbs.helmet) playerLimbs.helmet.visible = false;
                if(playerLimbs.torso) playerLimbs.torso.visible = false;
                if(playerLimbs.legL) playerLimbs.legL.visible = false;
                if(playerLimbs.legR) playerLimbs.legR.visible = false;
                playerMesh.children.forEach(c => { if(c.userData.isTorsoPart) c.visible = false; });
            } else if (isMelee) {
                // Reset camera pitch per allineamento orizzonte in melee
                euler.x = 0.43;
                if(playerLimbs.helmet) playerLimbs.helmet.visible = true;
                if(playerLimbs.torso) playerLimbs.torso.visible = true;
                if(playerLimbs.legL) playerLimbs.legL.visible = true;
                if(playerLimbs.legR) playerLimbs.legR.visible = true;
                playerMesh.children.forEach(c => { if(c.userData.isTorsoPart) c.visible = true; });
            }
            
            playerLimbs.armL.visible = true; playerLimbs.armR.visible = true;

            const modeText = isMelee ? "MELEE" : (isRanged ? "RANGED" : "ARCO");
            document.getElementById('weapon-mode-text').innerText = modeText;
            document.getElementById('weapon-mode-text').style.color = isMelee ? "orange" : (isRanged ? "cyan" : "lightgreen");
            
            const opacity = isMelee ? '0.4' : '1';
            document.querySelectorAll('.action-slot:not(.slot-q):not(.slot-e):not(.slot-r):not(#slot-5):not(#slot-6):not(#slot-7)').forEach(s => s.style.opacity = opacity);
            
            // Highlight Active Weapon Slot
            document.getElementById('slot-q').classList.remove('active');
            document.getElementById('slot-e').classList.remove('active');
            
            if (isMelee || isRanged) {
                 document.getElementById('slot-q').classList.add('active');
            } else if (isBow) {
                 document.getElementById('slot-e').classList.add('active');
            }
        }

function updateSwordAnimation(delta) {
            if (isWhirlwinding) {
                const speed = 20; swordContainer.rotation.z = -Math.PI/2; swordContainer.rotation.y += delta * speed; swordContainer.rotation.x = Math.PI/2;
                playerLimbs.armR.rotation.x = -Math.PI/2; playerLimbs.armL.rotation.x = -Math.PI/2; return; 
            }
            if(isAttacking && weaponMode !== 'bow') { attackTimer += delta * 15; if(attackTimer > Math.PI) isAttacking = false; }
            if(weaponMode==='melee') {
                let targetRotZ = 0; 
                let targetRotY = 0; 
                let armRotX = 0; 
                
                if (isAttacking) { 
                    const progress = attackTimer / Math.PI; 
                    const sweep = Math.cos(progress * Math.PI); 
                    armRotX = -Math.PI/4; 
                    targetRotZ = Math.PI/2; 
                    targetRotY = sweep * 1.5; 
                    swordContainer.rotation.z = targetRotZ; 
                    swordContainer.rotation.y = targetRotY + Math.PI; 
                    swordContainer.rotation.x = Math.PI/2; 
                    playerLimbs.armR.rotation.x = armRotX;
                } else { 
                    swordContainer.rotation.set(-Math.PI/2, Math.PI, 0); 
                }
            }
        }

function updatePhysics(delta) {
            if (playerStats.mana < playerStats.maxMana) playerStats.mana += GAME_CONFIG.PHYSICS.MANA_REGEN * delta;
            let isRegenStaminaBlocked = isBlocking || isWhirlwinding;
            if (isSprinting && (moveForward||moveBackward||moveLeft||moveRight) && playerStats.stamina > 0 && !isBlocking) { 
                playerStats.stamina -= GAME_CONFIG.PHYSICS.SPRINT_STAMINA_COST * delta; isRegenStaminaBlocked = true; 
            }
            if (isBlocking) {
                playerStats.stamina -= GAME_CONFIG.PHYSICS.BLOCK_STAMINA_COST * delta * 10; if (playerStats.stamina <= 0) stopBlocking(); isRegenStaminaBlocked = true; 
            } 
            if (!isRegenStaminaBlocked) {
                if (playerStats.stamina < playerStats.maxStamina) playerStats.stamina += GAME_CONFIG.PHYSICS.STAMINA_REGEN * delta;
            }
            let speed = GAME_CONFIG.PHYSICS.SPEED;
            if (velocity.y != 0) playerStats.isFalling = true;
            if(isBlocking) speed *= 0.5;
            if (isSprinting && (moveForward||moveBackward||moveLeft||moveRight) && playerStats.stamina > 0 && !isBlocking) { speed*=GAME_CONFIG.PHYSICS.SPRINT_MULTIPLIER; }
            
            velocity.x -= velocity.x*5*delta; velocity.z -= velocity.z*5*delta; velocity.y -= GAME_CONFIG.PHYSICS.GRAVITY*delta;
            
            const rotY = playerMesh.rotation.y;
            let moving = false;
            const moveVec = new THREE.Vector3();
            if (moveForward) { moveVec.add(new THREE.Vector3(-Math.sin(rotY),0,-Math.cos(rotY))); moving=true; }
            if (moveBackward) { moveVec.add(new THREE.Vector3(-Math.sin(rotY),0,-Math.cos(rotY)).negate()); moving=true; }
            if (moveRight) { moveVec.add(new THREE.Vector3(Math.cos(rotY),0,-Math.sin(rotY))); moving=true; }
            if (moveLeft) { moveVec.add(new THREE.Vector3(Math.cos(rotY),0,-Math.sin(rotY)).negate()); moving=true; }
            if(moving) {
                moveVec.normalize(); velocity.addScaledVector(moveVec, speed * delta);
                if(!playerStats.isFalling) { distanceSinceStep += speed * delta; if(distanceSinceStep > 400.0) { playSound('step'); distanceSinceStep = 0; } }
            }
            playerMesh.position.addScaledVector(velocity, delta);
            if(playerMesh.position.y <= 6) { 
                if (velocity.y <= 0) { 
                    playerMesh.position.y = 6; 
                    velocity.y = 0; 
                    canJump = true; 
                    playerStats.isFalling = false; 
                } 
            } else {
                canJump = false;
            }
            playerStats.stamina = Math.max(0, Math.min(playerStats.maxStamina, playerStats.stamina));
            
            // Check healing temple proximity (da WORLD_CONFIG)
            if (window.healingTotemPos) {
                const totemConfig = WORLD_CONFIG.HEALING_TOTEM;
                const dist = playerMesh.position.distanceTo(window.healingTotemPos);
                if (dist < totemConfig.radius) {
                    playerStats.hp = playerStats.maxHp;
                    playerStats.mana = playerStats.maxMana;
                    playerStats.stamina = playerStats.maxStamina;
                    if (!window.lastHealMessage || Date.now() - window.lastHealMessage > 2000) {
                        addFloatingText(playerMesh.position.clone().add(new THREE.Vector3(0, 12, 0)), '✨ COMPLETAMENTE GUARITO ✨', 0x00ffff, 2.0);
                        window.lastHealMessage = Date.now();
                    }
                }
            }
            
            obstacles.forEach(o => { 
                const box = new THREE.Box3().setFromObject(o);
                
                // Dimensioni del player per la collisione
                const playerRadius = 2.2; // Raggio di collisione orizzontale (aumentato)
                const playerHeight = 12; // Altezza totale del player
                const playerBaseY = playerMesh.position.y;
                
                // Crea una box per il player che copre TUTTO il corpo (gambe incluse)
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(playerMesh.position.x - playerRadius, playerBaseY, playerMesh.position.z - playerRadius),
                    new THREE.Vector3(playerMesh.position.x + playerRadius, playerBaseY + playerHeight, playerMesh.position.z + playerRadius)
                );
                
                // Controlla se le box si intersecano
                if (playerBox.intersectsBox(box)) {
                    const obstacleHeight = box.max.y - box.min.y;
                    
                    // Se l'ostacolo è abbastanza alto, spingi il player indietro
                    if (obstacleHeight > 1.5 || box.max.y > playerBaseY + 1.5) {
                        // Calcola la direzione di push-back dal centro dell'ostacolo
                        const dir = new THREE.Vector3().subVectors(playerMesh.position, o.position).normalize().setY(0);
                        const pushForce = 15 * delta * 60; // Push force aumentato
                        playerMesh.position.addScaledVector(dir, pushForce);
                    }
                }
            });
            if (socket && myId) {
                const animState = isSprinting ? 'run' : (moving) ? 'walk' : 'idle';
                socket.emit('playerMovement', { position: playerMesh.position, rotation: { x: playerMesh.rotation.x, y: playerMesh.rotation.y, z: playerMesh.rotation.z }, animState: animState, weaponMode: weaponMode });
            }
        }

function updateCamera() {
            const headPos = playerMesh.position.clone().add(new THREE.Vector3(0,8.5,0));
            if (weaponMode === 'ranged' || weaponMode === 'bow') { 
                camera.position.copy(headPos).addScaledVector(new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(euler.x, euler.y, euler.z, 'YXZ')), 0.5); 
                camera.quaternion.setFromEuler(euler); 
                playerMesh.visible = true; 
            } else { 
                const offset = new THREE.Vector3(0, 16, 25).applyEuler(new THREE.Euler(euler.x, euler.y, 0, 'YXZ')); 
                camera.position.copy(headPos).add(offset); 
                const lookAtPoint = playerMesh.position.clone().add(new THREE.Vector3(0, 12, 0)); 
                camera.lookAt(lookAtPoint); 
            }
        }

